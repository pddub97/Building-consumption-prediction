# -*- coding: utf-8 -*-
"""mainForecast.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ayN2Isv2xsbf9WCWcPkKtojzQhtnZdBP
"""

import pandas as pd
import numpy as np
import time
import datetime

import matplotlib.pyplot as plt

from sklearn.model_selection import TimeSeriesSplit
from sklearn.model_selection import cross_val_score as cvs
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import GridSearchCV
import lightgbm as lgb

import warnings
warnings.filterwarnings('ignore')

def preprocess(fname, hourly=True):
    df = pd.read_excel(fname).set_index('time')
    if hourly and len(df) > 0:
        df = df.reindex(pd.date_range(df.index[0], df.index[-1], freq='H'))
    return df

def lagging(input, lag_days):
  output = input[24*lag_days:]
  output.index = range(0, output.shape[0])

  for i in range(lag_days):
    output['lag_'+str(i+1)+'_days'] = output['sum']
    for j in range(len(output)):
      output['lag_'+str(i+1)+'_days'][j] = input['sum'][j - (i+1)*24 + lag_days*24]
  output['week_average'] = output.iloc[:, -lag_days:].mean(axis = 1)
  prev_hour = input['sum'][24*lag_days -1: -1]
  prev_hour.index = range(0, output.shape[0])
  output['prev_hour'] = prev_hour

  output.index = range(0, output.shape[0])
  output
  return output

def preparation(input):
  temp = input.copy()
  temp['sum'] = temp['_Bus_1_p_TM1H_mv_val'] + temp['_Bus_2_p_TM1H_mv_val'] + temp['_Bus_3_p_TM1H_mv_val'] + temp['_Bus_4_p_TM1H_mv_val']

  # Массив из потребления,часа, дня недели, месяца и года
  to_predict = temp[['time', 'sum']]
  to_predict['hour'] = to_predict['time'].dt.hour
  to_predict['weekday'] = to_predict['time'].dt.weekday
  to_predict['month'] = to_predict['time'].dt.month
  to_predict['year'] = to_predict['time'].dt.year
  to_predict['day'] = to_predict['time'].dt.dayofyear

  # Заполнение NaN величин ближайшими
  to_predict['sum'] = to_predict['sum'].interpolate(method = 'nearest')
  to_predict['sum'][0] = to_predict['sum'][1]

  output = to_predict
  return output

def filtering(input):
  output = pd.DataFrame(columns = input.columns)
  for i in input['year'].unique():
    for j in input[input['year'] == i]['day'].unique():
      day = input[(input['year'] == i) & (input['day'] == j)]
      if day['sum'].max() > 60 and day['sum'].min() > 35:
        output = output.append(day)
  return output

def generate_X_for_next_hour(input):
  time_new = input.iloc[-1]['time'] + datetime.timedelta(hours=1)
  output = pd.DataFrame([time_new])
  output.columns = ['time']
  output['hour'] = output['time'].dt.hour
  output['weekday'] = output['time'].dt.weekday
  output['month'] = output['time'].dt.month
  output['year'] = output['time'].dt.year
  output['day'] = output['time'].dt.dayofyear
  output = input.append(output)
  output.index = range(output.shape[0])
  return output

def fit(fname):
    global my_lgb, df
    df = preprocess(fname)
    df['time'] = df.index
    df.index = range(df.shape[0])
    to_predict = preparation(df)

    to_predict_lagged = lagging(to_predict, 7)

    filtered = filtering(to_predict_lagged)

    X = filtered.drop(['sum', 'time'], axis = 1)
    y = filtered[['sum']]

    my_lgb = lgb.LGBMRegressor(objective = "poisson",
        metric ="rmse",
        force_row_wise = True,
        sub_row = 0.75,
        bagging_freq = 1,
        lambda_l2 = 0.1,
        verbosity= 1,
        num_iterations = 2000,
        num_leaves= 128,
        min_data_in_leaf = 50 )
    
    my_lgb.fit(X.astype(float), y)
    

def predict(dt, extra_data='upd.xlsx'):
    global my_lgb, df
    
    df_upd = preprocess(extra_data)
    df_upd['time'] = df_upd.index
    
    df_new = df.append(df_upd)
    df_new.index = range(df_new.shape[0])
    



    to_predict = preparation(df_new)
    to_predict = to_predict[-14*24:]

    predictions = []
    for i in range(24):

      to_predict = generate_X_for_next_hour(to_predict)

      

      to_predict_lagged = lagging(to_predict, 7)

      X = to_predict_lagged.drop(['sum', 'time'], axis = 1).iloc[[-1]]

      y = my_lgb.predict(X)[0]
      to_predict['sum'].iloc[-1] = y
    if df_upd.shape[0] != 0:
      result = to_predict[['time', 'sum']].iloc[-24:-df_upd.shape[0]]
    else:
      result = to_predict[['time', 'sum']].iloc[-24:]







    
    return result

